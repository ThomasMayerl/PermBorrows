import "defs.vpr"

// ################# EXAMPLE PROVENANCE 1 ######################## //
/*
fn foo() {
	let mut val = (1, 2);
	let ptr = &raw mut val.1;
	bar(ptr);
	// assert!(val.0 == 1); // would fail
 	assert!(val.1 == 2); // OK
}

#[requires(acc(*ptr-1))]
#[ensures(acc(*ptr-1))]
fn bar(ptr: *mut i32) {
	*(ptr-1) = 2;
}*/


method bar(_1: Ref)
requires p_frac(_1) == 1/2 // because _1 itself is not mutable in bar
requires acc(p_RawPtr(_1, s_Int_i32_type()), p_frac(_1))
// requires(acc(*(ptr - 1)))
requires p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac > 0/1
requires p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac <= write
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1)
requires p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1))
ensures acc(p_RawPtr(_1, s_Int_i32_type()), p_frac(_1))
ensures p_frac(_1) == 1/2
// ensures(acc(*(ptr - 1)))
ensures p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))).frac > 0/1
ensures p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))).frac <= write
ensures s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))), -1)
ensures p_Int_i32(old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))), -1)))
{
    // *(ptr-1) = 2
    exhale p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1))
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1), s_Int_i32_cons(2), 1/1)
}

method foo() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _1_prov: Seq[Ref]
    // let mut val = (1, 2);
    inhale tag_of_ref(_1) == 0
    p_Tuple_2_assign(_1, s_Int_i32_type(), s_Int_i32_type(), s_Tuple_2_cons(make_generic_s_Int_i32(s_Int_i32_cons(1)), make_generic_s_Int_i32(s_Int_i32_cons(2))), write)
    // PCG says expand
    unfold acc(p_Tuple_2(_1, s_Int_i32_type(), s_Int_i32_type()), p_frac(_1))
    _1_prov := Seq(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type()))
    inhale tag_of_ref(_2) == 0
    _2 := s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type())
    make_concrete_Int_i32(_2, p_frac(_2))
    make_concrete_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), p_frac(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type())))
    // let ptr = &raw mut val.1
    inhale tag_of_ref(_3) == 0
    p_RawPtr_assign(_3, s_Int_i32_type(), s_RawPtr_cons(1, p_frac(_2), _1_prov, s_Int_i32_type()), 1/2)
    // bar(ptr)
    bar(_3)
    // assert!(val.1 == 2)
    assert acc(p_Int_i32(_2), wildcard)
    assert p_Int_i32_snap(_2, p_frac(_2)).val == 2
    // should not work
    // assert!(val.0 == 1)
    assert acc(p_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type())), wildcard) // this should still work
    assert p_Int_i32_snap(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), p_frac(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()))).val == 2 // this should not
}


// ################# EXAMPLE PROVENANCE 2 ######################## //
/*
fn foo() {
	let mut val = (1, 2);
	let tmp = &'raw mut val.1;
    let ptr = tmp as *mut i32;
	bar(ptr); // should not be able to prove precondition because pointer inherits provenance of reference
}

#[requires(acc(*ptr-1))]
#[ensures(acc(*ptr-1))]
fn bar(ptr: *mut i32) {
	*(ptr-1) = 2;
}*/

method bar2(_1: Ref)
requires p_frac(_1) == 1/2 // because _1 itself is not mutable in bar
requires acc(p_RawPtr(_1, s_Int_i32_type()), p_frac(_1))
// requires(acc(*(ptr - 1)))
requires p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac > 0/1
requires p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac <= write
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1)
requires p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1))
ensures acc(p_RawPtr(_1, s_Int_i32_type()), p_frac(_1))
ensures p_frac(_1) == 1/2
// ensures(acc(*(ptr - 1)))
ensures p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))).frac > 0/1
ensures p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))).frac <= write
ensures s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))), -1)
ensures p_Int_i32(old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), old(p_frac(_1))), -1)))
{
    // *(ptr-1) = 2
    exhale p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1))
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), -1), s_Int_i32_cons(2), 1/1)
}

method foo2() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _4: Ref
    var _1_prov: Seq[Ref]
    // let mut val = (1, 2);
    inhale tag_of_ref(_1) == 0
    p_Tuple_2_assign(_1, s_Int_i32_type(), s_Int_i32_type(), s_Tuple_2_cons(make_generic_s_Int_i32(s_Int_i32_cons(1)), make_generic_s_Int_i32(s_Int_i32_cons(2))), write)
    // PCG says expand
    unfold acc(p_Tuple_2(_1, s_Int_i32_type(), s_Int_i32_type()), p_frac(_1))
    _1_prov := Seq(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type()))
    inhale tag_of_ref(_2) == 0
    _2 := s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type())
    make_concrete_Int_i32(_2, p_frac(_2))
    make_concrete_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), p_frac(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type())))
    // let tmp = &'raw mut val.1;
    var _3_for_2: Ref := p_Int_i32_retag(_2, write)
    p_MutRef_assign(_3, s_Int_i32_type(), s_MutRef_cons(_3_for_2, 1/1, s_Int_i32_type()), 1/2)
    // let ptr = tmp as *mut i32;
    var _3_snap: s_MutRef := p_MutRef_snap(_3, s_Int_i32_type(), p_frac(_3))
    inhale tag_of_ref(_4) == 0
    p_RawPtr_assign(_4, s_Int_i32_type(), s_RawPtr_cons(0, _3_snap.frac, Seq(_3_snap.addr), s_Int_i32_type()), 1/2)
    assert _3_snap.frac == 1/1
    assert (p_RawPtr_snap(_4, s_Int_i32_type(), p_frac(_4))).frac == 1/1
    assert acc(p_Int_i32(_3_snap.addr), _3_snap.frac)
    assert p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_4, s_Int_i32_type(), p_frac(_4)), 0))
    bar2(_4)
}