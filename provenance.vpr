import "defs.vpr"

// ################# EXAMPLE PROVENANCE 1 ######################## //
/*
fn foo() {
	let mut val = (1, 2);
	let ptr = &raw mut val.1;
	bar(ptr);
	// assert!(val.0 == 1); // would fail
 	assert!(val.1 == 2); // OK
}

#[requires(acc(*ptr-1))]
#[ensures(acc(*ptr-1))]
fn bar(ptr: *mut i32) {
	*(ptr-1) = 2;
}*/


method bar(_1: Ref)
requires acc(_1.p_frac)
requires _1.p_frac > 0/1
requires _1.p_frac < write
requires acc(p_RawPtr(_1, s_Int_i32_type()), _1.p_frac)
// requires(acc(*(ptr - 1)))
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1)
requires acc(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac)
requires s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac > 0/1
requires s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac <= write
requires p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1))
ensures acc(_1.p_frac)
ensures _1.p_frac == old(_1.p_frac)
ensures acc(p_RawPtr(_1, s_Int_i32_type()), _1.p_frac)
// ensures(acc(*(ptr - 1)))
ensures s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1)
ensures acc(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac)
ensures s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac > 0/1
ensures s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac <= write
ensures s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1) == old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1))
ensures p_Int_i32(old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1)))
{
    // *(ptr-1) = 2
    exhale p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1))
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1), s_Int_i32_cons(2), 1/1)
}

method foo() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _1_prov: Seq[Ref]
    // let mut val = (1, 2);
    inhale tag_of_ref(_1) == 0
    inhale acc(_1.p_frac)
    p_Tuple_2_assign(_1, s_Int_i32_type(), s_Int_i32_type(), s_Tuple_2_cons(make_generic_s_Int_i32(s_Int_i32_cons(1)), make_generic_s_Int_i32(s_Int_i32_cons(2))), write)
    // PCG says expand
    unfold acc(p_Tuple_2(_1, s_Int_i32_type(), s_Int_i32_type()), _1.p_frac)
    _1_prov := Seq(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type()))
    inhale tag_of_ref(_2) == 0
    inhale acc(_2.p_frac)
    _2 := s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type())
    make_concrete_Int_i32(_2, _2.p_frac)
    make_concrete_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()).p_frac)
    // let ptr = &raw mut val.1
    inhale tag_of_ref(_3) == 0
    inhale acc(_3.p_frac)
    p_RawPtr_assign(_3, s_Int_i32_type(), s_RawPtr_cons(1, _1_prov, s_Int_i32_type()), 1/2)
    // bar(ptr)
    bar(_3)
    // assert!(val.1 == 2)
    assert acc(p_Int_i32(_2), wildcard)
    assert p_Int_i32_snap(_2, _2.p_frac).val == 2
    // should not work
    // assert!(val.0 == 1)
    assert acc(p_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type())), wildcard) // this should still work
    assert p_Int_i32_snap(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()).p_frac).val == 2 // this should not
}


// ################# EXAMPLE PROVENANCE 2 ######################## //
/*
fn foo() {
	let mut val = (1, 2);
	let tmp = &'raw mut val.1;
    let ptr = tmp as *mut i32;
	bar(ptr); // should not be able to prove precondition because pointer inherits provenance of reference
}

#[requires(acc(*ptr-1))]
#[ensures(acc(*ptr-1))]
fn bar(ptr: *mut i32) {
	*(ptr-1) = 2;
}*/

method bar2(_1: Ref)
requires acc(_1.p_frac)
requires _1.p_frac > 0/1
requires _1.p_frac < write
requires acc(p_RawPtr(_1, s_Int_i32_type()), _1.p_frac)
// requires(acc(*(ptr - 1)))
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1)
requires acc(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac)
requires s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac > 0/1
requires s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac <= write
requires p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1))
ensures acc(_1.p_frac)
ensures _1.p_frac == old(_1.p_frac)
ensures acc(p_RawPtr(_1, s_Int_i32_type()), _1.p_frac)
// ensures(acc(*(ptr - 1)))
ensures s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), old(_1.p_frac)), -1)
ensures acc(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac)
ensures s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac > 0/1
ensures s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1).p_frac <= write
ensures s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1) == old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1))
ensures p_Int_i32(old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1)))
{
    // *(ptr-1) = 2
    exhale p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1))
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), -1), s_Int_i32_cons(2), 1/1)
}

method foo2() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _4: Ref
    var _1_prov: Seq[Ref]
    // let mut val = (1, 2);
    inhale tag_of_ref(_1) == 0
    inhale acc(_1.p_frac)
    p_Tuple_2_assign(_1, s_Int_i32_type(), s_Int_i32_type(), s_Tuple_2_cons(make_generic_s_Int_i32(s_Int_i32_cons(1)), make_generic_s_Int_i32(s_Int_i32_cons(2))), write)
    // PCG says expand
    unfold acc(p_Tuple_2(_1, s_Int_i32_type(), s_Int_i32_type()), _1.p_frac)
    _1_prov := Seq(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type()))
    inhale tag_of_ref(_2) == 0
    inhale acc(_2.p_frac)
    _2 := s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type())
    make_concrete_Int_i32(_2, _2.p_frac)
    make_concrete_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()).p_frac)
    // let tmp = &'raw mut val.1;
    var _3_for_2: Ref := p_Int_i32_retag(_2, write)
    inhale acc(_3.p_frac)
    p_MutRef_assign(_3, s_Int_i32_type(), s_MutRef_cons(_3_for_2, s_Int_i32_type()), 1/2)
    // let ptr = tmp as *mut i32;
    var _3_snap: s_MutRef := p_MutRef_snap(_3, s_Int_i32_type(), _3.p_frac)
    inhale tag_of_ref(_4) == 0
    inhale acc(_4.p_frac)
    p_RawPtr_assign(_4, s_Int_i32_type(), s_RawPtr_cons(0, Seq(_3_snap.addr), s_Int_i32_type()), 1/2)
    assert acc(p_Int_i32(_3_snap.addr), _3_snap.addr.p_frac)
    assert p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_4, s_Int_i32_type(), _4.p_frac), 0))
    bar2(_4)
}