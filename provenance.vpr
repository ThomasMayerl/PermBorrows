import "defs.vpr"

// ################# EXAMPLE PROVENANCE 1 ######################## //
/*
fn foo() {
	let mut val = (1, 2);
	let ptr = &raw mut val.1;
	bar(ptr);
	// assert!(val.0 == 1); // would fail
 	assert!(val.1 == 2); // OK
}

#[requires(acc(*ptr-1))]
#[ensures(acc(*ptr-1))]
fn bar(ptr: *mut i32) {
	*(ptr-1) = 2;
}*/


method bar(_1: Ref)
requires p_frac(_1) == 1/2 // because _1 itself is not mutable in bar
requires acc(p_RawPtr(_1, 0, s_Int_i32_type()), p_frac(_1))
// requires(acc(*(ptr - 1)))
requires p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).frac > 0/1
requires p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).frac <= write
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1)
requires p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).tag)
ensures acc(p_RawPtr(_1, 0, s_Int_i32_type()), p_frac(_1))
ensures p_frac(_1) == 1/2
// ensures(acc(*(ptr - 1)))
ensures p_RawPtr_snap(_1, 0, s_Int_i32_type(), old(p_frac(_1))).frac > 0/1
ensures p_RawPtr_snap(_1, 0, s_Int_i32_type(), old(p_frac(_1))).frac <= write
ensures s_RawPtr_In_Prov(p_RawPtr_snap(_1, 0, s_Int_i32_type(), old(p_frac(_1))), -1)
ensures p_Int_i32(old(s_RawPtr_deref(p_RawPtr_snap(_1, 0, s_Int_i32_type(), old(p_frac(_1))), -1)), old(p_RawPtr_snap(_1, 0, s_Int_i32_type(), old(p_frac(_1))).tag))
{
    // *(ptr-1) = 2
    assert p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).tag)
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).tag, s_Int_i32_cons(2), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).frac)
}

method foo() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _1_prov: Seq[Ref]
    // let mut val = (1, 2);
    p_Tuple_2_assign(_1, 0, s_Int_i32_type(), s_Int_i32_type(), s_Tuple_2_cons(make_generic_s_Int_i32(s_Int_i32_cons(1)), make_generic_s_Int_i32(s_Int_i32_cons(2))), write)
    // PCG says expand
    unfold acc(p_Tuple_2(_1, 0, s_Int_i32_type(), s_Int_i32_type()), p_frac(_1))
    _1_prov := Seq(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type()))
    _2 := s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type())
    make_concrete_Int_i32(_2, 0, p_frac(_2))
    make_concrete_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), 0, p_frac(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type())))
    // let ptr = &raw mut val.1
    p_RawPtr_assign(_3, 0, s_Int_i32_type(), s_RawPtr_cons(1, 0, p_frac(_2), _1_prov, s_Int_i32_type()), 1/2)
    // bar(ptr)
    bar(_3)
    // assert!(val.1 == 2)
    assert acc(p_Int_i32(_2, 0), wildcard)
    assert p_Int_i32_snap(_2, 0, p_frac(_2)).val == 2
    // should not work
    // assert!(val.0 == 1)
    assert acc(p_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), 0), wildcard) // this should still work
    assert p_Int_i32_snap(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), 0, p_frac(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()))).val == 2 // this should not
}


// ################# EXAMPLE PROVENANCE 2 ######################## //
/*
fn foo() {
	let mut val = (1, 2);
	let tmp = &'raw mut val.1;
    let ptr = tmp as *mut i32;
	bar(ptr); // should not be able to prove precondition because pointer inherits provenance of reference
}

#[requires(acc(*ptr-1))]
#[ensures(acc(*ptr-1))]
fn bar(ptr: *mut i32) {
	*(ptr-1) = 2;
}*/

method bar2(_1: Ref)
requires p_frac(_1) == 1/2 // because _1 itself is not mutable in bar
requires acc(p_RawPtr(_1, 0, s_Int_i32_type()), p_frac(_1))
// requires(acc(*(ptr - 1)))
requires p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).frac > 0/1
requires p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).frac <= write
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1)
requires p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).tag)
ensures acc(p_RawPtr(_1, 0, s_Int_i32_type()), p_frac(_1))
ensures p_frac(_1) == 1/2
// ensures(acc(*(ptr - 1)))
ensures p_RawPtr_snap(_1, old(0), s_Int_i32_type(), old(p_frac(_1))).frac > 0/1
ensures p_RawPtr_snap(_1, old(0), s_Int_i32_type(), old(p_frac(_1))).frac <= write
ensures s_RawPtr_In_Prov(p_RawPtr_snap(_1, old(0), s_Int_i32_type(), old(p_frac(_1))), -1)
ensures p_Int_i32(old(s_RawPtr_deref(p_RawPtr_snap(_1, old(0), s_Int_i32_type(), old(p_frac(_1))), -1)), old(p_RawPtr_snap(_1, old(0), s_Int_i32_type(), old(p_frac(_1))).tag))
{
    // *(ptr-1) = 2
    assert p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).tag)
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)), -1), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).tag, s_Int_i32_cons(2), p_RawPtr_snap(_1, 0, s_Int_i32_type(), p_frac(_1)).frac)
}

method foo2() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _4: Ref
    var _1_prov: Seq[Ref]
    // let mut val = (1, 2);
    p_Tuple_2_assign(_1, 0, s_Int_i32_type(), s_Int_i32_type(), s_Tuple_2_cons(make_generic_s_Int_i32(s_Int_i32_cons(1)), make_generic_s_Int_i32(s_Int_i32_cons(2))), write)
    // PCG says expand
    unfold acc(p_Tuple_2(_1, 0, s_Int_i32_type(), s_Int_i32_type()), p_frac(_1))
    _1_prov := Seq(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type()))
    _2 := s_Tuple_2_field1(_1, s_Int_i32_type(), s_Int_i32_type())
    make_concrete_Int_i32(_2, 0, p_frac(_2))
    make_concrete_Int_i32(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type()), 0, p_frac(s_Tuple_2_field0(_1, s_Int_i32_type(), s_Int_i32_type())))
    // let tmp = &'raw mut val.1;
    p_MutRef_assign(_3, 0, s_Int_i32_type(), s_MutRef_cons(_2, p_new_tag(), 1/1, s_Int_i32_type()), 1/2)
    var _3_snap: s_MutRef := p_MutRef_snap(_3, 0, s_Int_i32_type(), p_frac(_3))
    assert acc(p_Int_i32(_3_snap.addr, 0), p_MutRef_snap(_3, 0, s_Int_i32_type(), p_frac(_3)).frac)
    exhale acc(p_Int_i32(_3_snap.addr, 0), _3_snap.frac)
    inhale acc(p_Int_i32(_3_snap.addr, _3_snap.tag), _3_snap.frac)
    // let ptr = tmp as *mut i32;
    assert acc(p_Int_i32(_3_snap.addr, _3_snap.tag), _3_snap.frac)
    p_RawPtr_assign(_4, 0, s_Int_i32_type(), s_RawPtr_cons(0, _3_snap.tag, _3_snap.frac, Seq(_3_snap.addr), s_Int_i32_type()), 1/2)
    // bar(ptr)
    assert _3_snap.frac == 1/1
    assert (p_RawPtr_snap(_4, 0, s_Int_i32_type(), p_frac(_4))).frac == 1/1
    assert (p_RawPtr_snap(_4, 0, s_Int_i32_type(), p_frac(_4))).tag == _3_snap.tag
    assert acc(p_Int_i32(_3_snap.addr, _3_snap.tag), _3_snap.frac)
    assert p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_4, 0, s_Int_i32_type(), p_frac(_4)), 0), (p_RawPtr_snap(_4, 0, s_Int_i32_type(), p_frac(_4))).tag)
    bar2(_4)
}