import "defs.vpr"

// ################# EXAMPLE BASIC 1 ######################## //
/*
pub fn foo() {
    let mut v = 5;
    let tmp = &'raw mut v; let x = tmp as *mut i32;
    let y = bar(x);
    *y = 2;
    *x = 1;
    expire!(*x);
    assert!(v == 1);
}

requires acc!(*x)
ensures x === result
ensures acc!(*x)
fn bar(x: *mut i32) -> *mut i32 {
    x
}
*/

method foo() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _4: Ref
    // let mut v = 5;
    inhale tag_of_ref(_1) == 0
    inhale acc(_1.p_frac)
    p_Int_i32_assign(_1, s_Int_i32_cons(5), 1/1) // 1/1 because of let *mut*
    // let tmp = &'raw mut v;
    var _1_for_2: Ref := p_Int_i32_retag(_1, 1/1)
    inhale acc(_2.p_frac)
    p_MutRef_assign(_2, s_Int_i32_type(), s_MutRef_cons(_1_for_2, s_Int_i32_type()), 1/2) // 1/2 because of no mut of reference itself
    // let x = tmp as *mut i32;
    inhale tag_of_ref(_3) == 0
    inhale acc(_3.p_frac)
    p_RawPtr_assign(_3, s_Int_i32_type(), s_RawPtr_cons(0, Seq(p_MutRef_snap(_2, s_Int_i32_type(), _2.p_frac).addr), s_Int_i32_type()), 1/2)
    // let y = bar(x);
    inhale tag_of_ref(_4) == 0
    inhale acc(_4.p_frac)
    inhale _4.p_frac == write
    bar(_4, _3)
    var _ignored: Ref := p_RawPtr_retag(_4, s_Int_i32_type(), 1/2) // y is not mut
    // *y = 2;
    exhale acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_4, s_Int_i32_type(), _4.p_frac), 0)), 1/1) // 1/1 because we are writing
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_4, s_Int_i32_type(), _4.p_frac), 0), s_Int_i32_cons(2), 1/1)
    // *x = 1;
    exhale acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), _3.p_frac), 0)), 1/1) // 1/1 because we are writing
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), _3.p_frac), 0), s_Int_i32_cons(1), 1/1)
    // expire!(*x)
    p_Int_i32_unblock(_1, s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), _3.p_frac), 0), s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), _3.p_frac), 0).p_frac)
    // assert!(v == 1)
    assert p_Int_i32_snap(_1, 1/1) == s_Int_i32_cons(1)
}

method bar(_0: Ref, _1: Ref)
// definition of return value - we do not know if the caller places it into a mutable location or not
requires acc(_0.p_frac)
requires _0.p_frac == write
// definition of parameter - not declared as mut
requires acc(_1.p_frac)
requires (_1.p_frac) > 0/1
requires (_1.p_frac) < write
requires acc(p_RawPtr(_1, s_Int_i32_type()), _1.p_frac)
// requires acc(*x)
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0)
requires acc(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0).p_frac)
requires s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0).p_frac == write
requires acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0)), s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0).p_frac)
// definition of return value and parameter again
ensures acc(_0.p_frac)
ensures _0.p_frac == write
ensures acc(_1.p_frac)
ensures _1.p_frac == old(_1.p_frac)
ensures acc(p_RawPtr(_0, s_Int_i32_type()), _0.p_frac)
ensures acc(p_RawPtr(_1, s_Int_i32_type()), _1.p_frac)
ensures old(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac)) == p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac)
// ensures x === result
ensures old(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac)) == p_RawPtr_snap(_0, s_Int_i32_type(), _0.p_frac)
// ensures acc(*x)
ensures acc(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0).p_frac)
ensures old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0).p_frac) == write
ensures s_RawPtr_In_Prov(old(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac)), 0)
ensures acc(p_Int_i32(s_RawPtr_deref(old(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac)), 0)), old(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac), 0).p_frac))
{
    // return x
    var _1_tmp: s_RawPtr := p_RawPtr_snap(_1, s_Int_i32_type(), _1.p_frac)
    p_RawPtr_assign(_0, s_Int_i32_type(), s_RawPtr_cons(_1_tmp.addr, _1_tmp.prov, _1_tmp.T$0), _0.p_frac)
}