import "defs.vpr"

// ################# EXAMPLE BASIC 1 ######################## //
/*
pub fn foo() {
    let mut v = 5;
    let tmp = &'raw mut v; let x = tmp as *mut i32;
    let y = bar(x);
    *y = 2;
    *x = 1;
    expire!(*x);
    assert!(v == 1);
}

requires acc!(*x)
ensures x === result
ensures acc!(*x)
fn bar(x: *mut i32) -> *mut i32 {
    x
}
*/

method foo() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _4: Ref
    // let mut v = 5;
    inhale tag_of_ref(_1) == 0
    p_Int_i32_assign(_1, s_Int_i32_cons(5), 1/1) // 1/1 because of let *mut*
    // let tmp = &'raw mut v;
    var _1_for_2: Ref := p_Int_i32_retag(_1, 1/1)
    p_MutRef_assign(_2, s_Int_i32_type(), s_MutRef_cons(_1_for_2, p_frac(_1), s_Int_i32_type()), 1/2) // 1/2 because of no mut of reference itself
    // let x = tmp as *mut i32;
    inhale tag_of_ref(_3) == 0
    p_RawPtr_assign(_3, s_Int_i32_type(), s_RawPtr_cons(0, p_MutRef_snap(_2, s_Int_i32_type(), p_frac(_2)).frac, Seq(p_MutRef_snap(_2, s_Int_i32_type(), p_frac(_2)).addr), s_Int_i32_type()), 1/2)
    // let y = bar(x);
    inhale tag_of_ref(_4) == 0
    inhale p_frac(_4) == 1/2 // y is not mut
    bar(_4, _3)
    // *y = 2;
    exhale acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_4, s_Int_i32_type(), p_frac(_4)), 0)), 1/1) // 1/1 because we are writing
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_4, s_Int_i32_type(), p_frac(_4)), 0), s_Int_i32_cons(2), 1/1)
    // *x = 1;
    exhale acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), 0)), 1/1) // 1/1 because we are writing
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), 0), s_Int_i32_cons(1), 1/1)
    // expire!(*x)
    p_Int_i32_unblock(_1, s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), 0), p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)).frac)
    // assert!(v == 1)
    assert p_Int_i32_snap(_1, 1/1) == s_Int_i32_cons(1)
}

method bar(_0: Ref, _1: Ref)
// definition of return value - we do not know if the caller places it into a mutable location or not
requires p_frac(_0) > 0/1
requires p_frac(_0) <= write
// definition of parameter - not declared as mut
requires p_frac(_1) == 1/2
requires acc(p_RawPtr(_1, s_Int_i32_type()), p_frac(_1))
// requires acc(*x)
requires p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac == write
requires s_RawPtr_In_Prov(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), 0)
requires acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)), 0)), p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac)
// definition of return value and parameter again
ensures p_frac(_0) > 0/1
ensures p_frac(_0) <= write
ensures p_frac(_1) == 1/2
ensures acc(p_RawPtr(_0, s_Int_i32_type()), p_frac(_0))
ensures acc(p_RawPtr(_1, s_Int_i32_type()), p_frac(_1))
ensures old(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1))) == p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1))
// ensures x === result
ensures old(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1))) == p_RawPtr_snap(_0, s_Int_i32_type(), p_frac(_0))
// ensures acc(*x)
ensures old(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac) == write
ensures s_RawPtr_In_Prov(old(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1))), 0)
ensures acc(p_Int_i32(s_RawPtr_deref(old(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1))), 0)), old(p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1)).frac))
{
    // return x
    var _1_tmp: s_RawPtr := p_RawPtr_snap(_1, s_Int_i32_type(), p_frac(_1))
    p_RawPtr_assign(_0, s_Int_i32_type(), s_RawPtr_cons(_1_tmp.addr, _1_tmp.frac, _1_tmp.prov, _1_tmp.T$0), p_frac(_0))
}