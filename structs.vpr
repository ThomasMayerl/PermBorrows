import "defs.vpr"

// ################# EXAMPLE STRUCTS 1 ######################## //
/* 
fn foo() {
	let mut x = 5;
	let tmp = &'raw mut x;
	let p_x = tmp as *mut i32;
	let str = Tmp {
	    x: p_x, // Copy
	    y: 10
	};
	let p_x_2 = str.get_raw();
	unsafe {
	    *p_x = 6;
	    assert!(*p_x_2 == 6);
        assert!(p_x_2 === p_x); // Snapshot equality -> Same tag, same permissions
	    expire!(p_x_2);
        assert!(x == 6);
        // assert!(*p_x == 6); // Should fail
	}
}

struct Tmp {
    x: *mut i32,
    y: i32
}

impl Tmp {
    #[requires(acc(*self.x))]
    #[ensures(acc(*result))]
    #[ensures(old(self.x) === result)] // Snapshot equality -> Same tag, same permissions
    #[ensures(old(*self.x) == *result)]
    fn get_raw(&self) -> *mut i32 {
        self.x        
    }
}
*/


/* 
struct Tmp {
    x: *mut i32,
    y: i32
}
*/
adt s_Struct_str {
    s_Struct_str_cons(x: s_RawPtr, y: s_Int_i32)
}

predicate p_Struct_str(self: Ref) {
    p_RawPtr(s_Struct_Str_fieldX(self), s_Int_i32_type()) &&
    p_Int_i32(s_Struct_Str_fieldY(self))
}

function s_Struct_Str_fieldX(self: Ref): Ref
function s_Struct_Str_fieldY(self: Ref): Ref

function p_Struct_str_snap(self: Ref, frac: Perm): s_Struct_str 
    requires frac > 0/1
    requires frac <= write
    requires acc(p_Struct_str(self), frac)
{
    unfolding acc(p_Struct_str(self), frac) in
    s_Struct_str_cons(p_RawPtr_snap(s_Struct_Str_fieldX(self), s_Int_i32_type(), frac), p_Int_i32_snap(s_Struct_Str_fieldY(self), frac))
}

method p_Struct_Str_retag(parent: Ref, frac: Perm) returns (child: Ref)
    requires frac > 0/1 && frac <= write
    requires p_frac(parent) > 0/1 && p_frac(parent) <= write
    requires acc(p_Struct_str(parent), frac)
    ensures addr_of_ref(parent) == addr_of_ref(child)
    ensures tag_of_ref(parent) != tag_of_ref(child)
    ensures acc(p_Struct_str(child), frac)
    ensures p_Struct_str_snap(child, frac) == old(p_Struct_str_snap(parent, p_frac(parent)))
    ensures unfolding acc(p_Struct_str(child), frac) in p_RawPtr_snap(s_Struct_Str_fieldX(child), s_Int_i32_type(), frac) == old(unfolding acc(p_Struct_str(parent), frac) in p_RawPtr_snap(s_Struct_Str_fieldX(parent), s_Int_i32_type(), p_frac(parent)))
    ensures unfolding acc(p_Struct_str(child), frac) in p_Int_i32_snap(s_Struct_Str_fieldY(child), frac) == old(unfolding acc(p_Struct_str(parent), frac) in p_Int_i32_snap(s_Struct_Str_fieldY(parent), p_frac(parent)))

method p_Struct_Str_unblock(parent: Ref, child: Ref, frac: Perm) 
    requires frac > 0/1 && frac <= write
    requires frac + p_frac(parent) > 0/1 && frac + p_frac(parent) <= write
    requires acc(p_Struct_str(child), frac)
    requires addr_of_ref(parent) == addr_of_ref(child)
    requires tag_of_ref(parent) != tag_of_ref(child)
    ensures acc(p_Struct_str(parent), frac)
    ensures p_Struct_str_snap(parent, frac + p_frac(parent)) == old(p_Struct_str_snap(child, frac))
    ensures unfolding acc(p_Struct_str(parent), frac) in p_RawPtr_snap(s_Struct_Str_fieldX(parent), s_Int_i32_type(), frac + p_frac(parent)) == old(unfolding acc(p_Struct_str(child), frac) in p_RawPtr_snap(s_Struct_Str_fieldX(child), s_Int_i32_type(), frac))
    ensures unfolding acc(p_Struct_str(parent), frac) in p_Int_i32_snap(s_Struct_Str_fieldY(parent), frac + p_frac(parent)) == old(unfolding acc(p_Struct_str(child), frac) in p_Int_i32_snap(s_Struct_Str_fieldY(child), frac))

method p_Struct_Str_assign(self: Ref, value: s_Struct_str, frac: Perm)
    requires frac > 0/1
    requires frac <= write
    ensures acc(p_Struct_str(self), frac)
    ensures p_Struct_str_snap(self, frac) == value
    ensures p_frac(self) == frac
    ensures unfolding acc(p_Struct_str(self), frac) in p_frac(s_Struct_Str_fieldX(self)) == frac
    ensures unfolding acc(p_Struct_str(self), frac) in p_frac(s_Struct_Str_fieldY(self)) == frac

function s_Struct_Str_type(): Type

method Tmp_get_raw(_0: Ref, _1: Ref)
    // definition of parameter - not declared as mut
    requires p_frac(_1) == 1/2
    requires acc(p_MutRef(_1, s_Struct_Str_type()), p_frac(_1))
    requires p_frac(_0) > 0/1
    requires p_frac(_0) <= write
    requires p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)).frac > 0/1
    requires p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)).frac <= 1/1
    requires acc(p_Struct_str(p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)).addr), p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)).frac)
    //#[requires(acc(*self.x))]
    requires let mutRefSnap == (p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)))
        in let rawPtrSnap == (unfolding acc(p_Struct_str(mutRefSnap.addr), mutRefSnap.frac) in p_RawPtr_snap(s_Struct_Str_fieldX(mutRefSnap.addr), s_Int_i32_type(), mutRefSnap.frac)) in
        s_RawPtr_In_Prov(rawPtrSnap, 0)
    requires let mutRefSnap == (p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)))
        in let rawPtrSnap == (unfolding acc(p_Struct_str(mutRefSnap.addr), mutRefSnap.frac) in p_RawPtr_snap(s_Struct_Str_fieldX(mutRefSnap.addr), s_Int_i32_type(), mutRefSnap.frac)) in
        rawPtrSnap.frac == write
    requires let mutRefSnap == (p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)))
        in let rawPtrSnap == (unfolding acc(p_Struct_str(mutRefSnap.addr), mutRefSnap.frac) in p_RawPtr_snap(s_Struct_Str_fieldX(mutRefSnap.addr), s_Int_i32_type(), mutRefSnap.frac)) in
        acc(p_Int_i32(s_RawPtr_deref(rawPtrSnap, 0)), rawPtrSnap.frac)
    ensures p_frac(_1) == 1/2
    ensures acc(p_MutRef(_1, s_Struct_Str_type()), p_frac(_1))
    ensures p_frac(_0) > 0/1
    ensures p_frac(_0) <= write
    ensures acc(p_RawPtr(_0, s_Int_i32_type()), p_frac(_0))
    ensures p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)) == old(p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)))
    //#[ensures(acc(*result))]
    ensures let rawPtrSnap == (p_RawPtr_snap(_0, s_Int_i32_type(), p_frac(_0))) in
        rawPtrSnap.frac == write
    ensures let rawPtrSnap == (p_RawPtr_snap(_0, s_Int_i32_type(), p_frac(_0))) in
        s_RawPtr_In_Prov(rawPtrSnap, 0)
    ensures let rawPtrSnap == (p_RawPtr_snap(_0, s_Int_i32_type(), p_frac(_0))) in
        acc(p_Int_i32(s_RawPtr_deref(rawPtrSnap, 0)), rawPtrSnap.frac)
    // #[ensures(old(self.x) === result)] // Snapshot equality -> Same tag, same permissions
    ensures let mutRefSnap == (p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1))) in
        old(
            let rawPtrSnap == (unfolding acc(p_Struct_str(mutRefSnap.addr), mutRefSnap.frac) in p_RawPtr_snap(s_Struct_Str_fieldX(mutRefSnap.addr), s_Int_i32_type(), mutRefSnap.frac)) in
            rawPtrSnap
        ) == let rawPtrSnap == (p_RawPtr_snap(_0, s_Int_i32_type(), p_frac(_0))) in rawPtrSnap
    // #[ensures(old(*self.x) == *result)]
    ensures let mutRefSnap == (p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1))) in
        old(
            let rawPtrSnap == (unfolding acc(p_Struct_str(mutRefSnap.addr), mutRefSnap.frac) in p_RawPtr_snap(s_Struct_Str_fieldX(mutRefSnap.addr), s_Int_i32_type(), mutRefSnap.frac)) in
            let intSnap == (p_Int_i32_snap(s_RawPtr_deref(rawPtrSnap, 0), rawPtrSnap.frac)) in intSnap
        ) == (
            let rawPtrSnap == (p_RawPtr_snap(_0, s_Int_i32_type(), p_frac(_0))) in
            let intSnap == (p_Int_i32_snap(s_RawPtr_deref(rawPtrSnap, 0), rawPtrSnap.frac)) in intSnap
        )
    {
        // self.x
        p_RawPtr_assign(_0, s_Int_i32_type(), (
            let mutRefSnap == (p_MutRef_snap(_1, s_Struct_Str_type(), p_frac(_1)))
            in let rawPtrSnap == (unfolding acc(p_Struct_str(mutRefSnap.addr), mutRefSnap.frac) in p_RawPtr_snap(s_Struct_Str_fieldX(mutRefSnap.addr), s_Int_i32_type(), mutRefSnap.frac)) in
            rawPtrSnap
        ), p_frac(_0))
    }

function get_new_ghost_addr(): Ref

method foo() {
    var _1: Ref
    var _2: Ref
    var _3: Ref
    var _4: Ref
    var _5: Ref
    var _6: Ref
    
    //let mut x = 5;
    inhale tag_of_ref(_1) == 0
    p_Int_i32_assign(_1, s_Int_i32_cons(5), 1/1)

    //let tmp = &'raw mut x;
    var _2_for_1: Ref := p_Int_i32_retag(_1, write)
    p_MutRef_assign(_2,  s_Int_i32_type(), s_MutRef_cons(_2_for_1, 1/1, s_Int_i32_type()), 1/2)

    //let p_x = tmp as *mut i32;
    inhale tag_of_ref(_3) == 0
    p_RawPtr_assign(_3, s_Int_i32_type(), s_RawPtr_cons(0, p_MutRef_snap(_2, s_Int_i32_type(), p_frac(_2)).frac, Seq(p_MutRef_snap(_2, s_Int_i32_type(), p_frac(_2)).addr), s_Int_i32_type()), 1/2)
    
    /*
    let str = Tmp {
        x: p_x, // Copy
        y: 10
    };
    */
    
    inhale tag_of_ref(_4) == 0
    p_Struct_Str_assign(_4, s_Struct_str_cons(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), s_Int_i32_cons(10)), 1/2)

    assert unfolding acc(p_Struct_str(_4), p_frac(_4) / 2) in s_RawPtr_In_Prov(p_RawPtr_snap( s_Struct_Str_fieldX(_4), s_Int_i32_type(), 1/2), 0)

    //let p_x_2 = str.get_raw();
    // implicit reborrowing 
    // var _4_snap: s_Struct_str := p_Struct_str_snap(_4, p_frac(_4))
    // var _4_frac: Perm := p_frac(_4)
    // exhale acc(p_Struct_str(_4), p_frac(_4))
    // havoc p_frac(_4)
    // _4 := get_new_ghost_addr() // so that we can assign new permission amount
    // inhale tag_of_ref(_4) == 0
    // p_Struct_Str_assign(_4, _4_snap, _4_frac / 2)

    // var _5_for_4: Ref
    // inhale tag_of_ref(_5_for_4) != 0
    // inhale addr_of_ref(_5_for_4) == addr_of_ref(_4)
    // inhale tag_of_ref(_5) == 0

    
    var _5_for_4: Ref := p_Struct_Str_retag(_4, p_frac(_4) / 2)

    p_MutRef_assign(_5, s_Struct_Str_type(), s_MutRef_cons(_5_for_4, p_frac(_4) / 2, s_Struct_Str_type()), 1/2)

    inhale tag_of_ref(_6) == 0
    inhale p_frac(_6) == 1/2
   
    Tmp_get_raw(_6, _5)

    // *p_x = 6;
    exhale acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), 0)), p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)).frac)
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), 0), s_Int_i32_cons(6), p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)).frac)
    
    // assert!(p_x_2 === p_x);
    assert p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)) == p_RawPtr_snap(_6, s_Int_i32_type(), p_frac(_6))

    // expire!(p_x_2);
    p_Int_i32_unblock(_1, s_RawPtr_deref(p_RawPtr_snap(_6, s_Int_i32_type(), p_frac(_6)), 0), p_RawPtr_snap(_6, s_Int_i32_type(), p_frac(_6)).frac)
    
    // assert!(x == 6);
    assert p_Int_i32_snap(_1, p_frac(_1)) == s_Int_i32_cons(6)

    //assert!(*p_x == 6); // Should fail
    /*exhale acc(p_Int_i32(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), 0)), p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)).frac)
    p_Int_i32_assign(s_RawPtr_deref(p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)), 0), s_Int_i32_cons(6), p_RawPtr_snap(_3, s_Int_i32_type(), p_frac(_3)).frac)*/
}

// ################# EXAMPLE STRUCTS 2 ######################## //
/*
fn foo() {
	let mut last = ListNode {
	    next: std::ptr::null::<ListNode>() as *mut ListNode,
	    val: 6,
	};
	
	let mut first = ListNode {
	    next: &raw mut last, // auto folds because of acc invariant
	    val: 5,
	};
	unsafe {
        expand!(first.next);
	    assert!((*first.next).val == 6);
	    (*first.next).val = 7;
        assert!(last.val == 7);
        //first.next.val = 5; // Next line should fail if commented in
        condense!(first.next);
	}
	
}

struct ListNode {
    #[invariant(acc(*next))]
    #[invariant(val <= next.val)]
    next: *mut ListNode,
    val: i32
}
*/

function p_Struct_ListNode_val(self: Ref): Ref
function p_Struct_ListNode_next(self: Ref): Ref
function p_Struct_ListNode_type(): Type

predicate p_Struct_ListNode(self: Ref) {
    p_Int_i32(p_Struct_ListNode_val(self)) &&
    p_RawPtr(p_Struct_ListNode_next(self), p_Struct_ListNode_type()) &&

    p_frac(self) > 0/1 && p_frac(self) <= 1/1 &&
    let next_snap == (p_RawPtr_snap(p_Struct_ListNode_next(self), p_Struct_ListNode_type(), p_frac(self))) in (
        next_snap.prov != Seq() ==> (
            next_snap.frac > 0/1 && next_snap.frac <= write &&
            s_RawPtr_In_Prov(next_snap, 0) &&
            acc(p_Struct_ListNode(s_RawPtr_deref(next_snap, 0)), next_snap.frac) &&
            p_Int_i32_snap(p_Struct_ListNode_val(self), p_frac(self)).val <= unfolding acc(p_Struct_ListNode(s_RawPtr_deref(next_snap, 0)), next_snap.frac) in p_Int_i32_snap(p_Struct_ListNode_val(s_RawPtr_deref(next_snap, 0)), next_snap.frac).val
        )
    )
}

// method p_Struct_ListNode_assign(self: Ref, value: s_Struct_ListNode, frac: Perm)
//     requires frac > 0/1
//     requires frac <= write
//     ensures acc(p_Struct_str(self), frac)
//     ensures p_Struct_str_snap(self, frac) == value
//     ensures p_frac(self) == frac
//     ensures unfolding acc(p_Struct_str(self), frac) in p_frac(s_Struct_Str_fieldX(self)) == frac
//     ensures unfolding acc(p_Struct_str(self), frac) in p_frac(s_Struct_Str_fieldY(self)) == frac

// method foo2() {
//     var _1: Ref

//     /*
//     let mut last = ListNode {
// 	    next: std::ptr::null::<ListNode>() as *mut ListNode,
// 	    val: 6,
// 	};
//     */
//     inhale tag_of_ref(_1) == 0
//     p_Struct_ListNode_assign()
// }